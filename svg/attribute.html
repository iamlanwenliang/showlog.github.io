<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		<style type="text/css">
			textarea{
				height:200px;
				width:100%;
				background-color:#333;
				color:#fff;
				font-size:16px;
				font-weight:700;
			}
		</style>
	</head>
	<body>
		
		<h1>文章出处：http://www.zhangxinxu.com/wordpress/2014/08/svg-viewport-viewbox-preserveaspectratio/</h1>
		<h1 style="height:50px;width:100%;background-color:#666;text-align: center;color:#fff;font-size:24px;line-height: 50px;">基础属性修炼篇</h1>
		<h1>基本属性</h1>
		<textarea style="height:100px">下来主要介绍这几个属性：
			stroke
			stroke-width
			stroke-linecap
			stroke-dasharray
		</textarea>
		<h2>stroke属性</h2>
		<svg width="100%" height="200" version="1.1" >
			<g fill="none">
			  <path stroke="red" d="M5 20 l215 0" />
			  <path stroke="black" d="M5 40 l215 0" />
			  <path stroke="blue" d="M5 60 l215 0" />
			</g>
		</svg>
		<textarea style="height:220px;">解释：
			<svg width="100%" height="200" version="1.1" >
				<g fill="none">
				  <path stroke="red" d="M5 20 l215 0" />
				  <path stroke="black" d="M5 40 l215 0" />
				  <path stroke="blue" d="M5 60 l215 0" />
				</g>
			</svg>
			stroke属性用来定义图形、文本等的边线颜色
		</textarea>
		<h2>stroke-width属性</h2>
		<svg width="100%" height="200" version="1.1" >
			<g fill="none" stroke="black">
			  <path stroke-width="2" d="M5 20 l215 0" />
			  <path stroke-width="4" d="M5 40 l215 0" />
			  <path stroke-width="6" d="M5 60 l215 0" />
			</g>
		</svg>
		<textarea style="height:220px;">解释：
			<svg width="100%" height="200" version="1.1" >
				<g fill="none">
				  <path stroke-width="2" d="M5 20 l215 0" />
				  <path stroke-width="4" d="M5 40 l215 0" />
				  <path stroke-width="6" d="M5 60 l215 0" />
				</g>
			</svg>
			stroke-width属性用来定义图形或文字边线的宽度
		</textarea>
		<h2>stroke-linecap 属性</h2>
		<svg width="100%" height="200" version="1.1" >
			<g fill="none" stroke="black" stroke-width="20">
			  <path stroke-linecap="butt" d="M5 20 l215 0" />
			  <path stroke-linecap="round" d="M5 50 l215 0" />
			  <path stroke-linecap="square" d="M5 80 l215 0" />
			</g>
		</svg>
		<textarea style="height:220px;">解释：
			<svg width="100%" height="200" version="1.1" >
				<g fill="none" stroke="black" stroke-width="20">
				  <path stroke-linecap="butt" d="M5 20 l215 0" />
				  <path stroke-linecap="round" d="M5 40 l215 0" />
				  <path stroke-linecap="square" d="M5 60 l215 0" />
				</g>
			</svg>
			stroke-linecap属性用来定义开放式路径的端点的样子
		</textarea>
		<h2>stroke-dasharray 属性</h2>
		<svg width="100%" height="200" version="1.1" >
			<g fill="none" stroke="black" stroke-width="4">
			  <path stroke-dasharray="5,5" d="M5 20 l215 0" />
			  <path stroke-dasharray="10,10" d="M5 40 l215 0" />
			  <path stroke-dasharray="20,10,5,5,5,10" d="M5 60 l215 0" />
			</g>
		</svg>
		<textarea style="height:220px;">解释：
			<svg width="100%" height="200" version="1.1" >
				<g fill="none" stroke="black" stroke-width="4">
				  <path stroke-dasharray="5,5" d="M5 20 l215 0" />
				  <path stroke-dasharray="10,10" d="M5 40 l215 0" />
				  <path stroke-dasharray="20,10,5,5,5,10" d="M5 60 l215 0" />
				</g>
			</svg>
			stroke-dasharray属性用来创建虚线
		</textarea>
		<hr/>
		<h1>SVG的viewBox和preserveAspectRatio属性</h1>
		<textarea style="height:220px;">
			SVG可见区域(viewport)的大小可以想象成舞台大小，画布大小。
			<svg width=”500″ height=”300″></svg>
			上面的SVG代码定义了一个视区，宽500单位，高300单位。
			注意这里的措辞是“单位”，不是“像素”。虽然说，width/height如果是纯数字，使用的就是“像素”作为单位的。
			也就是说，上面SVG的视区大小就是500px * 300px.
			除了SVG本身，其他一些元素，例如<rect>的width/height属性也可以使用上面的这些单位，也是默认单位是像素。
		</textarea>
		<h2>viewBox属性</h2>
		<svg width="400" height="300" viewBox="0,0,40,30" style="border:1px solid #cd0000;">
		    <rect x="10" y="5" width="20" height="15" fill="#cd0000"/>
		</svg>
		<textarea style="height:220px;">
			<svg width="400" height="300" viewBox="0,0,40,30" style="border:1px solid #cd0000;">
			    <rect x="10" y="5" width="20" height="15" fill="#cd0000"/>
			</svg>
			如果不看viewBox, 你一定会觉得诧异——SVG尺寸明明有400*300像素，而小小的<rect>大小只有其1/20，但是显示出来的却占据了半壁江山！不科学啊！OK, 之所以小小矩形大显神威就是这里的viewBox起了推波助澜的作用。
			viewBox值有4个数字：
			viewBox="x, y, width, height"  // x:左上角横坐标，y:左上角纵坐标，width:宽度，height:高度
			viewBox顾名思意是“视区盒子”的意思，好比在说：“SVG啊，要不你就让我铺满你吧~”。更形象的解释就是：SVG就像是我们的显示器屏幕，viewBox就是截屏工具选中的那个框框，最终的呈现就是把框框中的截屏内容再次在显示器中全屏显示！
		</textarea>
		<p>更直观的解释：
			1. 如果没有viewBox, 应该是长这样的：</p>
		<svg width="400" height="300" style="border:1px solid #cd0000;">
		    <rect x="10" y="5" width="20" height="15" fill="#cd0000"/>
		</svg>
		<p><rect>大小只有整个SVG舞台的1/20.</p>
		<p>2. viewBox="0,0,40,30"相当于在SVG上圈了下图左上角所示的一个框框：</p>
		<img src="img/2014-08-27_102211.png" />
		<p>3. 然后把这个框框，连同框框里的小矩形一起放大到整个SVG大小（如下gif）:</p>
		<img src='img/2014-08-27_105046-viewbox.gif' />
		<h2>preserveAspectRatio</h2>
		<p>上面的例子，SVG的宽高比正好和viewBox的宽高比是一样的，都是4:3. 显然，实际应用viewBox不可能一直跟viewport穿同一条开裆裤。此时，就需要preserveAspectRatio出马了，此属性也是应用在<svg>元素上，且作用的对象都是viewBox。</p>
		<p>先看下猪是怎么跑的：</p>
		<p>preserveAspectRatio="xMidYMid meet"</p>>
		<p>下面我们来吃猪肉。</p>
		<p>preserveAspectRatio属性的值为空格分隔的两个值组合而成。例如，上面的xMidYMid和meet.第1个值表示，viewBox如何与SVG viewport对齐；第2个值表示，如何维持高宽比（如果有）。</p>
		<p>其中，第1个值又是由两部分组成的。前半部分表示x方向对齐，后半部分表示y方向对齐。家族成员如下：值含义</p>
		<table border="1" style= 'border-collapse:collapse; border-spacing:0px 10px;' >
			<tbody>
			<tr>
				<td>xMin</td>
				<td>viewport和viewBox左边对齐</td>
			</tr>
			<tr>
				<td>xMid</td>
				<td>viewport和viewBox x轴中心对齐</td>
			</tr>
			<tr>
				<td>xMax</td>
				<td>viewport和viewBox右边对齐</td>
			</tr>
			<tr>
				<td>YMin</td>
				<td>viewport和viewBox上边缘对齐。注意Y是大写。</td>
			</tr>
			<tr>
				<td>YMid</td>
				<td>viewport和viewBox y轴中心点对齐。注意Y是大写。</td>
			</tr>
			<tr>
				<td>YMax</td>
				<td>viewport和viewBox下边缘对齐。注意Y是大写。</td>
			</tr>
			</tbody>
		</table>
		<p>x, y自由合体就可以了，如：
			xMaxYMax
			xMidYMid
			亲爱的小伙伴，看出啥意思没？
			噔噔蹬蹬，没错，就是组合的意思：“右-下”和“中-中”对齐。恭喜你此处的知识点学习顺利毕业！</p>
		<p>preserveAspectRatio属性第2部分的值支持下面3个</p>
		<p>值含义</p>
		<table border="1" style= 'border-collapse:collapse; border-spacing:0px 10px;'>
			<tbody>
				<tr>
					<td>meet</td>
					<td>保持纵横比缩放viewBox适应viewport，受</td>
				</tr>
				<tr>
					<td>slice</td>
					<td>保持纵横比同时比例小的方向放大填满viewport，攻</td>
				</tr>
				<tr>
					<td>none</td>
					<td>扭曲纵横比以充分适应viewport，变态</td>
				</tr>
			</tbody>
		</table>
		<p>现在急需一个活生生的例子，让大家感受下这三个值的表现。</p>
		<div style="height:400px;width:600px;border:#666 solid 2px">
			<svg id="svg" width="400" height="200" viewBox="0 0 200 200" style="border:1px solid #cd0000;">
			    <rect x="10" y="10" width="150" height="150" fill="#cd0000"/>
			</svg>
			<p><input type="radio" id="radio0" name="ratio" value="" checked><label for="radio0">无preserveAspectRatio</label></p>
			<p><input type="radio" id="radio1" name="ratio" value="meet"><label for="radio1">meet</label></p>
			<p><input type="radio" id="radio2" name="ratio" value="slice"><label for="radio2">slice</label></p>
			<p><input type="radio" id="radio3" name="ratio" value="none"><label for="radio3">none</label></p>
		<script>
			var svg = document.getElementById("svg");
			svg && [].slice.call(document.querySelectorAll("input[type=radio]")).forEach(function(radio) {
			    radio.addEventListener("click", function() {
			        var value = this.value;
			        if (value == "") {
			            svg.removeAttribute("preserveAspectRatio");
			            return;
			        }
			        if (value != "none") {
			            value = "xMinYMin " + value;
			        }
			        svg.setAttribute("preserveAspectRatio", value);            
			    });
			});
		</script>
		</div>
		<p>它使用的代码是这样的：</p>
		<textarea>
			<svg width="400" height="200" viewBox="0 0 200 200" style="border:1px solid #cd0000;">
			  <rect x="10" y="10" width="150" height="150" fill="#cd0000"/>
			</svg>
		</textarea>
		<p>截取SVG左边一半(200正好宽度400的一般)作为视区，里面有个150*150的红色矩形。</p>
		<p>默认应该是"xMidYmid meet"效果。表现原理为：SVG宽400, 高200，viewBox宽200, 高200. x横轴比例是2, y纵轴比例是1. meet的作用是让viewBox等比例的同时，完全在SVG的viewport中显示。这里，最小比例是纵向的1，所以，实际上viewBox并没有任何的缩放。
		       我们只要对viewBox属性值做一点小小的修改（200→300），就可以感受到缩放了
		       改成300后，viewBox的高度就比viewport的200高，所以，viewBox要想完全适应viewport，就要进行缩放，所以，我们可以上到上面的矩形面积变小了，就是因为缩放的结果（缩放了200/300, 差不多原来的66.7%）。
		  slice也是要保持viewBox的纵横比的，不过，其作用是尽量填满viewport. 同样，这里viewBox宽度200，SVG的width是400. 显然，要想最大化充满，viewBox的宽度就需要扩大为原来的两倍。于是，就有了上图viewBox放大两倍后的效果。由于viewBox部分区域超出了viewport, 视区之外内容是不可见的，于是就出现了slice所表意的“剪切”效果。
		      如果是none, 则表示不关心比例，viewBox直接拉伸到最大填满viewport.原本好好的一个正方形，现在因为viewBox的拉伸，变成了一个宽高2:1的矩形了。</p>
		<h2>viewBox的对齐</h2>
		<p>千言万语不如一个可以自己动手体验的demo实在，：</p>
		<div style="height:400px;width:600px;border:#666 solid 2px">
			<svg id="svg1" width="400" height="200" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet" style="border:1px solid #cd0000;">
			    <rect x="10" y="10" width="80" height="80" fill="#cd0000"/>
			</svg>
			<p>meet/slice：<select id="select0">
			    <option value="meet" selected>meet</option>
			    <option value="slice">slice</option>
			</select></p>
			<p>x方向：
				<select id="select1">
				    <option value="xMin" selected>xMin</option>
				    <option value="xMid">xMid</option>
				    <option value="xMax">xMax</option>
				</select>
			</p>
			<p>y方向：
				<select id="select2">
				    <option value="YMin" selected>YMin</option>
				    <option value="YMid">YMid</option>
				    <option value="YMax">YMax</option>
				</select>
			</p>
			<script>
				var svg = document.getElementById("svg1"),
				    select0 = document.getElementById("select0"), 
				    select1 = document.getElementById("select1"), 
				    select2 = document.getElementById("select2");
				    
				if (svg && select0 && select1 && select2) {
				    [select0, select1, select2].forEach(function(select) {
				        select.onchange = function() {
				            svg.setAttribute("preserveAspectRatio", select1.value + select2.value + " " + select0.value);
				        }
				    });
				}
			</script>
		</div>
		<p>无论是meet还是slice，你是不可能在一种状态下同时看到x, y方向上的位移的。因为总会有一个方向是充满viewport的。</p>
	</body>
</html>

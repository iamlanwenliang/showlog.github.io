<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>对象的操作方法</title>
		<link href="../../../public/font/font.css" rel="stylesheet" />
		
	</head>
	<body>
		<h2>对象的操作方法</h2>
		<div style="padding-left:25px;">
   
	<h5>1.Object.assign() </h5>
	<p>
	Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
	</p>
	<p>
		例如：<br />
	  const object1 = {<br />
		<kon></kon><kon></kon>	  a: 1,<br />
		<kon></kon><kon></kon>	  b: 2,<br />
		<kon></kon><kon></kon>	  c: 3<br />
		<kon></kon>	};<br />
	const object3 = {<br />
	 <kon></kon><kon></kon>d: 1,<br />
	 <kon></kon><kon></kon> e: 2,<br />
	 <kon></kon><kon></kon> f: 3<br />
	<kon></kon>};<br />
	
	const object2 = Object.assign({}, object1,object3);<br />
	const object4 = object2;<br />
	console.log(object4);//{"a":1,"b":2,"c":3,"d":1,"e":2,"f":3}<br />
	object2.e = 0;<br />
	console.log(object2);//{"a":1,"b":2,"c":3,"d":1,"e":0,"f":3}<br />
	console.log(object1);//{"a":1,"b":2,"c":3}<br />
	console.log(object3);//{"d":1,"e":2,"f":3}<br />
	console.log(object4);//{"a":1,"b":2,"c":3,"d":1,"e":0,"f":3}<br />
	const object5 = {o:12};<br />
	Object.assign(object5, object1,object3)<br />
	console.log(object5);//{"o":12,"a":1,"b":2,"c":3,"d":1,"e":2,"f":3}<br />

	</p>
	<p>
		如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。<br />

Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。

String类型和 Symbol 类型的属性都会被拷贝。<br />

在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。<br />

注意，Object.assign 不会跳过那些值为 null 或 undefined 的源对象。如果细心的人可能会注意到深浅拷贝的问题，这个问题后面会说到。
	</p>
	<h5>2.Object.create() </h5>
	<p>
		Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。
	</p>
	<p>
		语法：<br />
		<kon></kon>Object.create(proto, [propertiesObject])<br />
		proto<br />
		<kon></kon>新创建对象的原型对象。<br />
		propertiesObject<br />
		<kon></kon>可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。
		<br />
		返回一个新对象，带着指定的原型对象和属性。如果proto参数不是 null 或一个对象，则抛出一个 TypeError 异常。
	</p>
	<p>
		用 Object.create实现类式继承<br />

下面的例子演示了如何使用Object.create()来实现类式继承。这是一个所有版本JavaScript都支持的单继承。
	</p>
	<p>
		// Shape - 父类(superclass)<br />
		function Shape() {<br />
		  <kon></kon>this.x = 0;<br />
		  <kon></kon>this.y = 0;<br />
		}<br />
		
		// 父类的方法<br />
		Shape.prototype.move = function(x, y) {<br />
		  <kon></kon>this.x += x;<br />
		  <kon></kon>this.y += y;<br />
		  <kon></kon>console.info('Shape moved.');<br />
		};<br />
		
		// Rectangle - 子类(subclass)<br />
		function Rectangle() {<br />
		  <kon></kon>Shape.call(this); // call super constructor.<br />
		}<br />
		
		// 子类续承父类<br />
		Rectangle.prototype = Object.create(Shape.prototype);<br />
		Rectangle.prototype.constructor = Rectangle;<br />
		
		// 因为使用“.prototype =...”后,constructor会改变为“=...”的那个<br />
		// constructor，所以要重新指定.constructor 为自身。<br />
		var rect = new Rectangle();<br />

		console.log('Is rect an instance of Rectangle?',<br />
		  rect instanceof Rectangle); // true<br />
		console.log('Is rect an instance of Shape?',<br />
		  rect instanceof Shape); // true<br />
		rect.move(1, 1); // Outputs, 'Shape moved.'<br />
	</p>
	<p>
		如果你希望能继承到多个对象，则可以使用混入的方式。
	</p>
	<p>
		function MyClass() {<br />
		  <kon></kon>   SuperClass.call(this);<br />
		   <kon></kon>  OtherSuperClass.call(this);<br />
		}<br />
		
		// 继承一个类<br />
		MyClass.prototype = Object.create(SuperClass.prototype);<br />
		// 混合其它<br />
		Object.assign(MyClass.prototype, OtherSuperClass.prototype);<br />
		// 重新指定constructor<br />
		MyClass.prototype.constructor = MyClass;<br />
		
		MyClass.prototype.myMethod = function() {<br />
		  <kon></kon>   // do a thing<br />
		};<br />
	</p>
	<p>
		Object.assign 会把  OtherSuperClass原型上的函数拷贝到 MyClass原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。Object.assign 是在 ES2015 引入的，且可用 polyfilled。
	</p>
	<h5>3.Object.defineProperties() </h5>
	<p>
		Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。
	</p>
	<p>
		语法：<br />
		<kon></kon>Object.defineProperties(obj, props)<br />
		参数：<br />
		<kon></kon>obj<br />
		<kon></kon>在其上定义或修改属性的对象。<br />
		<kon></kon>props<br />
		<kon></kon>要定义其可枚举属性或修改的属性描述符的对象。对象中存在的属性描述符主要有两种：数据描述符和访问器描述符（更多详情，请参阅Object.defineProperty()）。描述符具有以下键：
			<kon></kon>configurable<br />
			<kon></kon>true 当且仅当该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。<br />
			<kon></kon>默认为 false<br />
			<kon></kon>enumerable<br />
			<kon></kon>true 当且仅当在枚举相应对象上的属性时该属性显现。<br />
			<kon></kon>默认为 false<br />
			<kon></kon>value<br />
			<kon></kon>与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。<br />
			<kon></kon>默认为 undefined.<br />
			<kon></kon>writable<br />
			<kon></kon>true当且仅当与该属性相关联的值可以用assignment operator改变时。<br />
			<kon></kon>默认为 false<br />
			<kon></kon>get<br />
			<kon></kon>作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。<br />
			<kon></kon>默认为 undefined<br />
			<kon></kon>set<br />
			<kon></kon>作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。<br />
			<kon></kon>默认为 undefined<br />
	</p>
	<p>Object.defineProperties本质上定义了obj 对象上props的可枚举属性相对应的所有属性。</p>
	<p>
		var obj = {};<br />
		<kon></kon>	Object.defineProperties(obj, {<br />
			 <kon></kon><kon></kon> 'property1': {<br />
			  <kon></kon><kon></kon>  value: true,<br />
			 <kon></kon><kon></kon>   writable: true<br />
		<kon></kon><kon></kon>	  },<br />
			 <kon></kon><kon></kon> 'property2': {<br />
			  <kon></kon><kon></kon>  value: 'Hello',<br />
			 <kon></kon><kon></kon>   writable: false<br />
			 <kon></kon><kon></kon> }<br />
			  
		<kon></kon>	});<br />
			console.log(obj)//{property1: true, property2: "Hello"}<br />
			obj.property1 = false;<br />
			console.log(obj)//{property1: false, property2: "Hello"}<br />
			obj.property2 = "hi";<br />
			console.log(obj)//{property1: false, property2: "Hello"}<br />
	</p>
	<h5>Object.defineProperty() </h5>
	<p>
		Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。
	</p>
	<p>
		语法：<br />
		<kon></kon>Object.defineProperty(obj, prop, descriptor)<br />
		参数：<br />
		<kon></kon>obj<br />
		<kon></kon>要在其上定义属性的对象。<br />
		<kon></kon>prop<br />
		<kon></kon>要定义或修改的属性的名称。<br />
		<kon></kon>descriptor
		<kon></kon>将被定义或修改的属性描述符。<br />
	</p>
	<p>
		该方法允许精确添加或修改对象的属性。通过赋值来添加的普通属性会创建在属性枚举期间显示的属性（for...in 或 Object.keys 方法）， 这些值可以被改变，也可以被删除。这种方法允许这些额外的细节从默认值改变。默认情况下，使用Object.defineProperty()添加的属性值是不可变的。
	</p>
	<p>
		属性描述符<br />

 

			对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。访问器描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。
			<br />
			数据描述符和存取描述符均具有以下可选键值：<br />
			
			<kon></kon>configurable<br />
			<kon></kon>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。<br />
			<kon></kon>enumerable<br />
			<kon></kon>当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。<br />
			数据描述符同时具有以下可选键值：<br />
			
			<kon></kon>value<br />
			<kon></kon>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。<br />
			<kon></kon>writable<br />
			<kon></kon>当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。<br />
			<kon></kon>存取描述符同时具有以下可选键值：<br />
			
			<kon></kon>get<br />
			<kon></kon>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。<br />
			<kon></kon>set<br />
			<kon></kon>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。
	</p>
	<p>
		
		描述符可同时具有的键值<br />
		
		 <kon></kon><kon></kon>  configurable<kon></kon>	enumerable<kon></kon>	value<kon></kon>	writable<kon></kon>	get	<kon></kon>  set<br />
		数据描述符	 <kon></kon>     Yes	 <kon></kon><kon></kon>      Yes	<kon></kon><kon></kon>     Yes	 <kon></kon><kon></kon> Yes	<kon></kon>    No<kon></kon>	   No<br />
		存取描述符	 <kon></kon>     Yes	<kon></kon><kon></kon>       Yes	 <kon></kon><kon></kon>    No	  <kon></kon><kon></kon>    No	 <kon></kon>  Yes <kon></kon> Yes
		<br />
		如果一个描述符不具有value,writable,get 和 set 任意一个关键字，那么它将被认为是一个数据描述符。如果一个描述符同时有(value或writable)和(get或set)关键字，将会产生一个异常。
		记住，这些选项不一定是自身属性，如果是继承来的也要考虑。为了确认保留这些默认值，你可能要在这之前冻结 Object.prototype，明确指定所有的选项，或者将__proto__属性指向null。
	</p>
	<p>
		例如：<br />
		// 使用 __proto__<br />
		var obj = {};<br />
		var descriptor = Object.create(null); // 没有继承的属性<br />
		// 默认没有 enumerable，没有 configurable，没有 writable<br />
		descriptor.value = 'static';<br />
		Object.defineProperty(obj, 'key', descriptor);<br />
		
		// 显式<br />
		Object.defineProperty(obj, "key", {<br />
		  <kon></kon>enumerable: false,<br />
		  <kon></kon>configurable: false,<br />
		  <kon></kon>writable: false,<br />
		  <kon></kon>value: "static"<br />
		});<br />
		
		// 循环使用同一对象<br />
		function withValue(value) {<br />
		  <kon></kon>var d = withValue.d || (<br />
		   <kon></kon> withValue.d = {<br />
		    <kon></kon><kon></kon>  enumerable: false,<br />
		    <kon></kon><kon></kon>  writable: false,<br />
		    <kon></kon><kon></kon>  configurable: false,<br />
		    <kon></kon><kon></kon>  value: null<br />
		   <kon></kon> }<br />
		  <kon></kon>);<br />
		  <kon></kon>d.value = value;<br />
		  <kon></kon>return d;<br />
		}
		// ... 并且 ...<br />
		Object.defineProperty(obj, "key", withValue("static"));<br />
		
		// 如果 freeze 可用, 防止代码添加或删除对象原型的属性<br />
		// （value, get, set, enumerable, writable, configurable）<br />
		(Object.freeze||Object)(Object.prototype);<br />
	</p>
	<p>
		如果对象中不存在指定的属性，Object.defineProperty()就创建这个属性。当描述符中省略某些字段时，这些字段将使用它们的默认值。拥有布尔值的字段的默认值都是false。value，get和set字段的默认值为undefined。一个没有get/set/value/writable定义的属性被称为“通用的”，并被“键入”为一个数据描述符。
	</p>
	<p>
		例如：<br />
		var o = {}; // 创建一个新对象<br />

		// 在对象中添加一个属性与数据描述符的示例<br />
		Object.defineProperty(o, "a", {<br />
		  <kon></kon>value : 37,<br />
		  <kon></kon>writable : true,<br />
		  <kon></kon>enumerable : true,<br />
		  <kon></kon>configurable : true<br />
		});<br />
		
		// 对象o拥有了属性a，值为37<br />
		
		// 在对象中添加一个属性与存取描述符的示例<br />
		var bValue;<br />
		Object.defineProperty(o, "b", {<br />
		  <kon></kon>get : function(){<br />
		   <kon></kon><kon></kon> return bValue;<br />
		  <kon></kon>},<br />
		  <kon></kon>set : function(newValue){<br />
		  <kon></kon><kon></kon>  bValue = newValue;<br />
		  <kon></kon>},<br />
		  <kon></kon>enumerable : true,<br />
		  <kon></kon>configurable : true<br />
		});<br />
		
		o.b = 38;<br />
		// 对象o拥有了属性b，值为38<br />
		
		// o.b的值现在总是与bValue相同，除非重新定义o.b<br />
		
		// 数据描述符和存取描述符不能混合使用<br />
		Object.defineProperty(o, "conflict", {<br />
		 <kon></kon> value: 0x9f91102, <br />
		 <kon></kon> get: function() { <br />
		  <kon></kon><kon></kon>  return 0xdeadbeef; <br />
		 <kon></kon> } <br />
		});<br />
		// throws a TypeError: value appears only in data descriptors, get appears only in accessor descriptors
	</p>
	<p>
		修改属性<br />

		如果属性已经存在，Object.defineProperty()将尝试根据描述符中的值以及对象当前的配置来修改这个属性。如果旧描述符将其configurable 属性设置为false，则该属性被认为是“不可配置的”，并且没有属性可以被改变（除了单向改变 writable 为 false）。当属性不可配置时，不能在数据和访问器属性类型之间切换。
		<br />
		当试图改变不可配置属性（除了writable 属性之外）的值时会抛出{jsxref("TypeError")}}，除非当前值和新值相同。
	</p>
	<p>
		Writable 属性<br />

当writable属性设置为false时，该属性被称为“不可写”。它不能被重新分配。
	</p>
	<p>
		例如：<br />
		var o = {}; // Creates a new object<br />

		Object.defineProperty(o, 'a', {<br />
		 <kon></kon> value: 37,<br />
		  <kon></kon>writable: false<br />
		});<br />
		
		console.log(o.a); // logs 37<br />
		o.a = 25; // No error thrown<br />
		// (it would throw in strict mode,<br />
		// even if the value had been the same)<br />
		console.log(o.a); // logs 37. The assignment didn't work.<br />
		
		// strict mode<br />
		(function() {<br />
		  <kon></kon>'use strict';<br />
		  <kon></kon>var o = {};<br />
		 <kon></kon> Object.defineProperty(o, 'b', {<br />
		  <kon></kon><kon></kon>  value: 2,<br />
		  <kon></kon><kon></kon>  writable: false<br />
		  <kon></kon>});<br />
		  <kon></kon>o.b = 3; // throws TypeError: "b" is read-only<br />
		 <kon></kon> return o.b; // returns 2 without the line above<br />
		}());<br />
		//如示例所示，试图写入非可写属性不会改变它，也不会引发错误。
	</p>
	<p>
		Enumerable 特性<br />

 		enumerable定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举。
	</p>
	<p>
		例如：<br />
		var o = {};<br />
		Object.defineProperty(o, "a", { value : 1, enumerable:true });<br />
		Object.defineProperty(o, "b", { value : 2, enumerable:false });
		Object.defineProperty(o, "c", { value : 3 }); // enumerable defaults to false<br />
		o.d = 4; // 如果使用直接赋值的方式创建对象的属性，则这个属性的enumerable为true<br />
		
		for (var i in o) {    <br />
		 <kon></kon> console.log(i);  <br />
		}
		// 打印 'a' 和 'd' (in undefined order)<br />
		
		Object.keys(o); // ["a", "d"]<br />
		
		o.propertyIsEnumerable('a'); // true<br />
		o.propertyIsEnumerable('b'); // false<br />
		o.propertyIsEnumerable('c'); // false
	</p>
	<p>
		Configurable 特性<br />

configurable特性表示对象的属性是否可以被删除，以及除writable特性外的其他特性是否可以被修改。
	</p>
	<p>
		var o = {};<br />
		Object.defineProperty(o, "a", { get : function(){return 1;}, <br />
		         <kon></kon><kon></kon>                       configurable : false } );<br />
		
		// throws a TypeError<br />
		Object.defineProperty(o, "a", {configurable : true}); <br />
		// throws a TypeError<br />
		Object.defineProperty(o, "a", {enumerable : true}); <br />
		// throws a TypeError (set was undefined previously) <br />
		Object.defineProperty(o, "a", {set : function(){}}); <br />
		// throws a TypeError (even though the new get does exactly the same thing) <br />
		Object.defineProperty(o, "a", {get : function(){return 1;}});<br />
		// throws a TypeError<br />
		Object.defineProperty(o, "a", {value : 12});<br />
		
		console.log(o.a); // logs 1<br />
		delete o.a; // Nothing happens<br />
		console.log(o.a); // logs 1<br />
		//如果o.a的configurable属性为true，则不会抛出任何错误，并且该属性将在最后被删除。
	</p>
	<p>
		添加多个属性和默认值<br />

考虑特性被赋予的默认特性值非常重要，通常，使用点运算符和Object.defineProperty()为对象的属性赋值时，数据描述符中的属性默认值是不同的，如下例所示。
	</p>
	<p>
		var o = {};<br />

		o.a = 1;<br />
		// 等同于 :<br />
		Object.defineProperty(o, "a", {<br />
		 <kon></kon> value : 1,<br />
		 <kon></kon> writable : true,<br />
		  <kon></kon>configurable : true,<br />
		 <kon></kon> enumerable : true<br />
		});<br />
		
		
		// 另一方面，<br />
		Object.defineProperty(o, "a", { value : 1 });<br />
		// 等同于 :<br />
		Object.defineProperty(o, "a", {<br />
		 <kon></kon> value : 1,<br />
		 <kon></kon> writable : false,<br />
		 <kon></kon> configurable : false,<br />
		 <kon></kon> enumerable : false<br />
		});<br />
	</p>
	<p>
		一般的 Setters 和 Getters<br />

下面的例子展示了如何实现一个自存档对象。 当设置temperature 属性时，archive 数组会获取日志条目。
	</p>
	<p>
		下面的例子展示了如何实现一个自存档对象。 当设置temperature 属性时，archive 数组会获取日志条目。
	</p>
	<p>
		function Archiver() {<br />
		  <kon></kon>var temperature = null;<br />
		  <kon></kon>var archive = [];<br />
		
		 <kon></kon> Object.defineProperty(this, 'temperature', {<br />
		   <kon></kon><kon></kon> get: function() {<br />
		   <kon></kon><kon></kon><kon></kon>   console.log('get!');<br />
		    <kon></kon><kon></kon><kon></kon>  return temperature;<br />
		    <kon></kon><kon></kon>},<br />
		    <kon></kon><kon></kon>set: function(value) {<br />
		    <kon></kon><kon></kon><kon></kon>  temperature = value;<br />
		     <kon></kon><kon></kon><kon></kon> archive.push({ val: temperature });<br />
		    <kon></kon><kon></kon>}<br />
		  <kon></kon>});<br />
		
		  <kon></kon>this.getArchive = function() { return archive; };<br />
		}<br />
		
		var arc = new Archiver();<br />
		arc.temperature; // 'get!'<br />
		arc.temperature = 11;<br />
		arc.temperature = 13;<br />
		arc.getArchive(); // [{ val: 11 }, { val: 13 }]
	</p>
	<h5>5.Object.entries() </h5>
	<p>
		Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。
	</p>
	<p>
		语法：<br />
		<kon></kon>Object.entries(obj)<br />
		参数：<br />
		<kon></kon>obj<br />
<kon></kon>可以返回其可枚举属性的键值对的对象。<br />
	返回值：<br />

	<kon></kon>给定对象自身可枚举属性的键值对数组<br />
	
	Object.entries()返回一个数组，其元素是与直接在object上找到的可枚举属性键值对相对应的数组。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。
	</p>
	<p>
		将Object转换为Map:<br />
		<kon></kon>new Map() 构造函数接受一个可迭代的entries。借助Object.entries方法你可以很容易的将Object转换为Map
	</p>
	<p>
		例如：<br />
		var obj = { foo: "bar", baz: 42 }; <br />
		var map = new Map(Object.entries(obj));<br />
		console.log(map); // Map { foo: "bar", baz: 42 }
	</p>
	
	<h5>6.Object.freeze() </h5>
	<p>
		Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。
	</p>
	<p>
		语法：<br />
		<kon></kon>Object.freeze(obj)<br />
		参数：<br />
		<kon></kon>obj<br />
			要被冻结的对象。<br />
		返回被冻结的对象。
	</p>
	<p>
		被冻结对象自身的所有属性都不可能以任何方式被修改。任何修改尝试都会失败，无论是静默地还是通过抛出TypeError异常（最常见但不仅限于strict mode）。<br />

数据属性的值不可更改，访问器属性（有getter和setter）也同样（但由于是函数调用，给人的错觉是还是可以修改这个属性）。如果一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象。
	</p>
	<p>
		例如：<br />
		var obj = {<br />
		 <kon></kon> prop: function() {},<br />
		 <kon></kon> foo: 'bar'<br />
		};<br />
		
		// 新的属性会被添加, 已存在的属性可能<br />
		// 会被修改或移除<br />
		obj.foo = 'baz';<br />
		obj.lumpy = 'woof';<br />
		delete obj.prop;<br />
		
		// 作为参数传递的对象与返回的对象都被冻结<br />
		// 所以不必保存返回的对象（因为两个对象全等）<br />
		var o = Object.freeze(obj);<br />
		
		o === obj; // true<br />
		Object.isFrozen(obj); // === true<br />
		
		// 现在任何改变都会失效<br />
		obj.foo = 'quux'; // 静默地不做任何事<br />
		// 静默地不添加此属性<br />
		obj.quaxxor = 'the friendly duck';<br />
		<br />
		// 在严格模式，如此行为将抛出 TypeErrors<br />
		function fail(){<br />
		 <kon></kon> 'use strict';<br />
		 <kon></kon> obj.foo = 'sparky'; // throws a TypeError<br />
		 <kon></kon> delete obj.quaxxor; // throws a TypeError<br />
		<kon></kon>  obj.sparky = 'arf'; // throws a TypeError<br />
		}<br />
		
		fail();<br />
		
		// 试图通过 Object.defineProperty 更改属性<br />
		// 下面两个语句都会抛出 TypeError.<br />
		Object.defineProperty(obj, 'ohai', { value: 17 });<br />
		Object.defineProperty(obj, 'foo', { value: 'eit' });<br />
		
		// 也不可能设置属性<br />
		// 下面两个语句都会抛出 TypeError.<br />
		Object.setPrototypeOf(obj, { x: 20 })<br />
		obj.__proto__ = { x: 20 }<br />
	</p>
	<p>
		冻结数组<br />

		// 冻结的数组像一个元组。<br />
		// 元组(tuple):与数组类似,但元组一旦初始化就不能修改<br />
		
		let a=[0];<br />
		Object.freeze(a);<br />
		// 数组a现在不能被更改了.<br />
		a[0]=1;<br />
		a.push(2);<br />
		// a=[0]<br />
		// 冻结的数组可以正常地拆包.<br />
		let b, c;<br />
		[b,c]=Object.freeze([1,2]);<br />
		// b=1, c=2
	</p>
	<p>
		被冻结的对象是不可变的。但也不总是这样。下例展示了一个不是常量的冻结对象（浅冻结）。
	</p>
	<p>
		obj1 = {<br />
		 <kon></kon> internal: {}<br />
		};<br />
		
		Object.freeze(obj1);<br />
		obj1.internal.a = 'aValue';<br />
		
		obj1.internal.a // 'aValue'
	</p>
	<p>
		对于一个常量对象，整个引用图（直接和间接引用其他对象）只能引用不可变的冻结对象。冻结的对象被认为是不可变的，因为整个对象中的整个对象状态（对其他对象的值和引用）是固定的。注意，字符串，数字和布尔总是不可变的，而函数和数组是对象。
<br />
要使对象不可变，需要递归冻结每个类型为对象的属性（深冻结）。当你知道对象在引用图中不包含任何 环 (循环引用)时，将根据你的设计逐个使用该模式，否则将触发无限循环。对 deepFreeze()  的增强将是具有接收路径（例如Array）参数的内部函数，以便当对象进入不变时，可以递归地调用 deepFreeze() 。你仍然有冻结不应冻结的对象的风险，例如[window]。
	</p>
	<p>
		// 深冻结函数.<br />
		function deepFreeze(obj) {<br />
		
		 <kon></kon> // 取回定义在obj上的属性名<br />
		  <kon></kon>var propNames = Object.getOwnPropertyNames(obj);<br />
		
		  <kon></kon>// 在冻结自身之前冻结属性<br />
		 <kon></kon> propNames.forEach(function(name) {<br />
		  <kon></kon><kon></kon>  var prop = obj[name];<br />
		
		  <kon></kon><kon></kon>  // 如果prop是个对象，冻结它<br />
		   <kon></kon><kon></kon> if (typeof prop == 'object' && prop !== null) <br />
		    <kon></kon><kon></kon><kon></kon>  deepFreeze(prop);<br />
		 <kon></kon> });<br />
		
		  <kon></kon>// 冻结自身(no-op if already frozen)<br />
		  <kon></kon>return Object.freeze(obj);<br />
		}<br />
		
		obj2 = {<br />
		  <kon></kon>internal: {}<br />
		};<br />
		
		deepFreeze(obj2);<br />
		obj2.internal.a = 'anotherValue';<br />
		obj2.internal.a; // undefined
	</p>
	
	<h5>7.Object.getOwnPropertyDescriptor() </h5>
	<p>
		Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）
	</p>
	<p>
		语法：<br />
		<kon></kon>Object.getOwnPropertyDescriptor(obj, prop)<br />
		参数：<br />
		<kon></kon>obj<br />
		<kon></kon>需要查找的目标对象<br />
		<kon></kon>prop<br />
		<kon></kon>目标对象内属性名称（String类型）<br />
		
		如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined。
	</p>
	<p>
		该方法允许对一个属性的描述进行检索。在 Javascript 中， 属性 由一个字符串类型的“名字”（name）和一个“属性描述符”（property descriptor）对象构成。更多关于属性描述符类型以及他们属性的信息可以查看：Object.defineProperty.
<br />
一个属性描述符是一个记录，由下面属性当中的某些组成的：<br />
		<kon></kon>value<br />
		<kon></kon><kon></kon>该属性的值(仅针对数据属性描述符有效)<br />
		<kon></kon>writable<br />
		<kon></kon><kon></kon>当且仅当属性的值可以被改变时为true。(仅针对数据属性描述有效)<br />
		<kon></kon>get<br />
		<kon></kon><kon></kon>获取该属性的访问器函数（getter）。如果没有访问器， 该值为undefined。(仅针对包含访问器或设置器的属性描述有效)<br />
		<kon></kon>set<br />
		<kon></kon><kon></kon>获取该属性的设置器函数（setter）。 如果没有设置器， 该值为undefined。(仅针对包含访问器或设置器的属性描述有效)<br />
		<kon></kon>configurable<br />
		<kon></kon><kon></kon>当且仅当指定对象的属性描述可以被改变或者属性可被删除时，为true。<br />
		<kon></kon>enumerable<br />
		<kon></kon><kon></kon>当且仅当指定对象的属性可以被枚举出时，为 true。
	</p>
	<p>
		var o, d;<br />

		o = { get foo() { return 17; } };<br />
		d = Object.getOwnPropertyDescriptor(o, "foo");<br />
		// d {<br />
		//   configurable: true,<br />
		//   enumerable: true,
		//   get: /*the getter function*/,<br />
		//   set: undefined<br />
		// }<br />
		
		o = { bar: 42 };<br />
		d = Object.getOwnPropertyDescriptor(o, "bar");<br />
		// d {<br />
		//   configurable: true,<br />
		//   enumerable: true,<br />
		//   value: 42,<br />
		//   writable: true<br />
		// }<br />
		
		o = {};<br />
		Object.defineProperty(o, "baz", {<br />
		  <kon></kon>value: 8675309,<br />
		 <kon></kon> writable: false,<br />
		 <kon></kon> enumerable: false<br />
		});<br />
		d = Object.getOwnPropertyDescriptor(o, "baz");<br />
		// d {<br />
		//   value: 8675309,<br />
		//   writable: false,<br />
		//   enumerable: false,<br />
		//   configurable: false<br />
		// }<br />
	</p>
	
	
	<h5>8.Object.getOwnPropertyDescriptors() </h5>
	<p>
		Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。
	</p>
	<p>
		语法：<br />
		<kon></kon>Object.getOwnPropertyDescriptors(obj)<br />
		参数：<br />
		<kon></kon>任意对象<br />
		所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。<br />
		
	</p>
	<p>
		浅拷贝一个对象<br />

Object.assign() 方法只能拷贝源对象的可枚举的自身属性，同时拷贝时无法拷贝属性的特性们，而且访问器属性会被转换成数据属性，也无法拷贝源对象的原型，该方法配合 Object.create() 方法可以实现上面说的这些。
	</p>
	<p>
		Object.create(<br />
		  <kon></kon>Object.getPrototypeOf(obj), <br />
		  <kon></kon>Object.getOwnPropertyDescriptors(obj) <br />
		);
	</p>
	<p>
		创建子类
<br />
创建子类的典型方法是定义子类，将其原型设置为超类的实例，然后在该实例上定义属性。这可能会让尴尬，特别是对于 getters 和 setter 而言。 相反，您可以使用此代码设置原型：
	</p>
	<p>
		function superclass() {}<br />
		superclass.prototype = {<br />
		  <kon></kon>// 在这里定义方法和属性<br />
		};<br />
		function subclass() {}<br />
		subclass.prototype = Object.create(superclass.prototype, Object.getOwnPropertyDescriptors({<br />
		 <kon></kon> // 在这里定义方法和属性<br />
		}));
	</p>
	<h5>9.Object.getOwnPropertyNames() </h5>
	<p>
		Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。
	</p>
	<p>
		语法：<br />
		<kon></kon>Object.getOwnPropertyNames(obj)<br />
		参数：<br />
		<kon></kon>obj<br />
		一个对象，其自身的可枚举和不可枚举属性的名称被返回。<br />
		返回值在给定对象上找到的属性对应的字符串数组。<br />
		
		Object.getOwnPropertyNames() 返回一个数组，该数组对元素是 obj自身拥有的枚举或不可枚举属性名称字符串。 数组中枚举属性的顺序与通过 for...in 循环（或 Object.keys）迭代该对象属性时一致。数组中不可枚举属性的顺序未定义。
	</p>
	<p>
		使用 Object.getOwnPropertyNames()例如：<br />
		var arr = ["a", "b", "c"];<br />
		console.log(Object.getOwnPropertyNames(arr).sort()); // ["0", "1", "2", "length"]<br />
		
		// 类数组对象<br />
		var obj = { 0: "a", 1: "b", 2: "c"};<br />
		console.log(Object.getOwnPropertyNames(obj).sort()); // ["0", "1", "2"]<br />
		
		// 使用Array.forEach输出属性名和属性值<br />
		Object.getOwnPropertyNames(obj).forEach(function(val, idx, array) {<br />
		 <kon></kon> console.log(val + " -> " + obj[val]);<br />
		});<br />
		// 输出<br />
		// 0 -> a<br />
		// 1 -> b<br />
		// 2 -> c<br />
		
		//不可枚举属性<br />
		var my_obj = Object.create({}, {<br />
		  <kon></kon>getFoo: {<br />
		  <kon></kon><kon></kon>  value: function() { return this.foo; },<br />
		   <kon></kon><kon></kon> enumerable: false<br />
		  <kon></kon>}<br />
		});<br />
		my_obj.foo = 1;<br />
		
		console.log(Object.getOwnPropertyNames(my_obj).sort()); // ["foo", "getFoo"]
	</p>
	<p>
		如果你只要获取到可枚举属性，查看Object.keys或用for...in循环（还会获取到原型链上的可枚举属性，不过可以使用hasOwnProperty()方法过滤掉）。
<br />
下面的例子演示了该方法不会获取到原型链上的属性：
	</p>
	<p>
		function ParentClass() {}<br />
		ParentClass.prototype.inheritedMethod = function() {};<br />
		
		function ChildClass() {<br />
		  <kon></kon>this.prop = 5;<br />
		  <kon></kon>this.method = function() {};<br />
		}<br />
		
		ChildClass.prototype = new ParentClass;<br />
		ChildClass.prototype.prototypeMethod = function() {};<br />
		
		console.log(<br />
		  <kon></kon>Object.getOwnPropertyNames(<br />
		    <kon></kon><kon></kon>new ChildClass()  // ["prop", "method"]<br />
		  <kon></kon>)<br />
		);<br />
	</p>
	<p>
		只获取不可枚举的属性<br />
		下面的例子使用了 Array.prototype.filter() 方法，从所有的属性名数组（使用Object.getOwnPropertyNames()方法获得）中去除可枚举的属性（使用Object.keys()方法获得），剩余的属性便是不可枚举的属性了：
	</p>
	<p>
		var target = myObject;<br />
		var enum_and_nonenum = Object.getOwnPropertyNames(target);<br />
		var enum_only = Object.keys(target);<br />
		var nonenum_only = enum_and_nonenum.filter(function(key) {<br />
		    <kon></kon>var indexInEnum = enum_only.indexOf(key);<br />
		    <kon></kon>if (indexInEnum == -1) {<br />
		    <kon></kon><kon></kon>    // 没有发现在enum_only健集中意味着这个健是不可枚举的,<br />
		     <kon></kon><kon></kon>   // 因此返回true 以便让它保持在过滤结果中<br />
		     <kon></kon><kon></kon>   return true;<br />
		    <kon></kon>} else {<br />
		    <kon></kon><kon></kon>    return false;<br />
		    <kon></kon>}<br />
		});<br />
		
		console.log(nonenum_only);<br />
		
		//注：Array.filter(filt_func)方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。
	</p>
	
	
	<h5>10.Object.getOwnPropertySymbols() </h5>
	
	<p>
		Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。
	</p>
	<p>
		语法：<br />
		<kon></kon>Object.getOwnPropertySymbols(obj)<br />
		参数<br />
		<kon></kon>obj<br />
		要返回 Symbol 属性的对象。<br />
		<kon></kon>返回值：<br />
		在给定对象自身上找到的所有 Symbol 属性的数组。
	</p>
	<p>
		与Object.getOwnPropertyNames()类似，您可以将给定对象的所有符号属性作为 Symbol 数组获取。 请注意，Object.getOwnPropertyNames()本身不包含对象的 Symbol 属性，只包含字符串属性。
<br />
因为所有的对象在初始化的时候不会包含任何的 Symbol，除非你在对象上赋值了 Symbol 否则Object.getOwnPropertySymbols()只会返回一个空的数组。
	</p>
	<p>
		var obj = {};<br />
		var a = Symbol("a");<br />
		var b = Symbol.for("b");<br />
		
		obj[a] = "localSymbol";<br />
		obj[b] = "globalSymbol";<br />
		
		var objectSymbols = Object.getOwnPropertySymbols(obj);<br />
		
		console.log(objectSymbols.length); // 2<br />
		console.log(objectSymbols)         // [Symbol(a), Symbol(b)]<br />
		console.log(objectSymbols[0])      // Symbol(a)<br />
	</p>
	
	
	<h5>11.Object.getPrototypeOf() </h5>
	<p>
		Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）。
	</p>
	<p>
		语法<br />
		Object.getPrototypeOf(object)<br />
		参数<br />
		obj<br />
		要返回其原型的对象。<br />
		返回值<br />
		
		给定对象的原型。如果没有继承属性，则返回 null 。
	</p>
	<p>
		var proto = {};<br />
		var obj = Object.create(proto);<br />
		Object.getPrototypeOf(obj) === proto; // true<br />
		
		var reg = /a/;<br />
		Object.getPrototypeOf(reg) === RegExp.prototype; // true
	</p>
	<p>
		注：Object.getPrototypeOf(Object)  不是  Object.prototype
		
	</p>
	<p>
		JavaScript中的 Object 是构造函数（创建对象的包装器）。<br />
		一般用法是：<br />
		var obj = new Object();<br />
		
		所以：<br />
		Object.getPrototypeOf( Object );               // ƒ () { [native code] }<br />
		Object.getPrototypeOf( Function );             // ƒ () { [native code] }<br />
		
		Object.getPrototypeOf( Object ) === Function.prototype;        // true<br />
		
		Object.getPrototypeOf( Object )是把Object这一构造函数看作对象，<br />
		返回的当然是函数对象的原型，也就是 Function.prototype。<br />
		
		正确的方法是，Object.prototype是构造出来的对象的原型。<br />
		var obj = new Object();<br />
		Object.prototype === Object.getPrototypeOf( obj );              // true<br />
		
		Object.prototype === Object.getPrototypeOf( {} );     <br />
	</p>
	<h5>12.Object.is() </h5>
	<p>
		Object.is()方法判断两个值是否是相同的值。
	</p>
	<p>
		参数<br />
		
		<kon></kon>value1<br />
		<kon></kon>需要比较的第一个值。<br />
		<kon></kon>value2<br />
		<kon></kon>需要比较的第二个值。<br />
		返回值<br />
		
		<kon></kon>表示两个参数是否相同的Boolean 。
	</p>
	<p>
		Object.is() 判断两个值是否相同。如果下列任何一项成立，则两个值相同：<br />
		
		<kon></kon>两个值都是 undefined<br />
		<kon></kon>两个值都是 null<br />
		<kon></kon>两个值都是 true 或者都是 false<br />
		<kon></kon>两个值是由相同个数的字符按照相同的顺序组成的字符串<br />
		<kon></kon>两个值指向同一个对象<br />
		<kon></kon>两个值都是数字并且<br />
			<kon></kon><kon></kon>都是正零 +0<br />
			<kon></kon><kon></kon>都是负零 -0<br />
			<kon></kon><kon></kon>都是 NaN<br />
			<kon></kon><kon></kon>都是除零和 NaN 外的其它同一个数字<br />
		这种相等性判断逻辑和传统的 == 运算符所用的不同，== 运算符会对它两边的操作数做隐式类型转换（如果它们类型不同），然后才进行相等性比较，（所以才会有类似 "" == false 为 true 的现象），但 Object.is 不会做这种类型转换。
		<br />
		这与===运算符也不一样。===运算符（和==运算符）将数字值-0和+0视为相等，并认为Number.NaN不等于NaN。
	</p>
	<p>
		Object.is('foo', 'foo');     // true<br />
		Object.is(window, window);   // true<br />
		
		Object.is('foo', 'bar');     // false<br />
		Object.is([], []);           // false<br />
		
		var test = { a: 1 };<br />
		Object.is(test, test);       // true<br />
		
		Object.is(null, null);       // true<br />
		
		// 特例<br />
		Object.is(0, -0);            // false<br />
		Object.is(-0, -0);           // true<br />
		Object.is(NaN, 0/0);         // true
	</p>
	
	<h5>13.Object.isExtensible() </h5>
	<p>
		Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。
	</p>
	<p>
		语法<br />
		
		<kon></kon>Object.isExtensible(obj)<br />
		参数<br />
		
		<kon></kon>obj<br />
		返回：
		<kon></kon>需要检测的对象
	</p>
	<p>
		默认情况下，对象是可扩展的：即可以为他们添加新的属性。以及它们的 __proto__  属性可以被更改。Object.preventExtensions，Object.seal 或 Object.freeze 方法都可以标记一个对象为不可扩展（non-extensible）。
	</p>
	<p>
		// 新对象默认是可扩展的.<br />
		var empty = {};<br />
		Object.isExtensible(empty); // === true<br />
		
		// ...可以变的不可扩展.<br />
		Object.preventExtensions(empty);<br />
		Object.isExtensible(empty); // === false<br />
		
		// 密封对象是不可扩展的.<br />
		var sealed = Object.seal({});<br />
		Object.isExtensible(sealed); // === false<br />
		
		// 冻结对象也是不可扩展.<br />
		var frozen = Object.freeze({});<br />
		Object.isExtensible(frozen); // === false
	</p>
	
	<h5>14.Object.isFrozen() </h5>
	<p>
		Object.isFrozen()方法判断一个对象是否被冻结。
	</p>
	<p>
		语法<br />

		<kon></kon>Object.isFrozen(obj)<br />
		参数<br />
		
		<kon></kon>obj<br />
		被检测的对象。<br />
		<kon></kon>返回值<br />
		
		表示给定对象是否被冻结的Boolean。
	</p>
	<p>
		一个对象是冻结的是指它不可扩展，所有属性都是不可配置的，且所有数据属性（即没有getter或setter组件的访问器的属性）都是不可写的。
	</p>
	<p>
		// 一个对象默认是可扩展的,所以它也是非冻结的.<br />
		Object.isFrozen({}); // === false<br />
		
		// 一个不可扩展的空对象同时也是一个冻结对象.<br />
		var vacuouslyFrozen = Object.preventExtensions({});<br />
		Object.isFrozen(vacuouslyFrozen) //=== true;<br />
		
		// 一个非空对象默认也是非冻结的.<br />
		var oneProp = { p: 42 };<br />
		Object.isFrozen(oneProp) //=== false<br />
		
		// 让这个对象变的不可扩展,并不意味着这个对象变成了冻结对象,<br />
		// 因为p属性仍然是可以配置的(而且可写的).<br />
		Object.preventExtensions(oneProp);<br />
		Object.isFrozen(oneProp) //=== false<br />
		
		// ...如果删除了这个属性,则它会成为一个冻结对象.<br />
		delete oneProp.p;<br />
		Object.isFrozen(oneProp) //=== true<br />
		
		// 一个不可扩展的对象,拥有一个不可写但可配置的属性,则它仍然是非冻结的.<br />
		var nonWritable = { e: "plep" };<br />
		Object.preventExtensions(nonWritable);<br />
		Object.defineProperty(nonWritable, "e", { writable: false }); // 变得不可写<br />
		Object.isFrozen(nonWritable) //=== false<br />
		
		// 把这个属性改为不可配置,会让这个对象成为冻结对象.<br />
		Object.defineProperty(nonWritable, "e", { configurable: false }); // 变得不可配置<br />
		Object.isFrozen(nonWritable) //=== true<br />
		
		// 一个不可扩展的对象,拥有一个不可配置但可写的属性,则它仍然是非冻结的.<br />
		var nonConfigurable = { release: "the kraken!" };<br />
		Object.preventExtensions(nonConfigurable);<br />
		Object.defineProperty(nonConfigurable, "release", { configurable: false });<br />
		Object.isFrozen(nonConfigurable) //=== false<br />
		
		// 把这个属性改为不可写,会让这个对象成为冻结对象.<br />
		Object.defineProperty(nonConfigurable, "release", { writable: false });<br />
		Object.isFrozen(nonConfigurable) //=== true<br />
		
		// 一个不可扩展的对象,值拥有一个访问器属性,则它仍然是非冻结的.<br />
		var accessor = { get food() { return "yum"; } };<br />
		Object.preventExtensions(accessor);<br />
		Object.isFrozen(accessor) //=== false<br />
		
		// ...但把这个属性改为不可配置,会让这个对象成为冻结对象.<br />
		Object.defineProperty(accessor, "food", { configurable: false });<br />
		Object.isFrozen(accessor) //=== true<br />
		
		// 使用Object.freeze是冻结一个对象最方便的方法.<br />
		var frozen = { 1: 81 };<br />
		Object.isFrozen(frozen) //=== false<br />
		Object.freeze(frozen);<br />
		Object.isFrozen(frozen) //=== true<br />
		
		// 一个冻结对象也是一个密封对象.<br />
		Object.isSealed(frozen) //=== true<br />
		
		// 当然,更是一个不可扩展的对象.<br />
		Object.isExtensible(frozen) //=== false
	</p>
	
	
	
	
	<h5>15.Object.isSealed()  </h5>
	<p>
		Object.isSealed() 方法判断一个对象是否被密封。
	</p>
	<p>
		语法<br />
		
		<kon></kon>Object.isSealed(obj)<br />
		参数<br />
		
		<kon></kon>obj<br />
		要被检查的对象。<br />
		<kon></kon>返回值<br />
		
		表示给定对象是否被密封的一个Boolean 。
	</p>
	<p>
		如果这个对象是密封的，则返回 true，否则返回 false。密封对象是指那些不可 扩展 的，且所有自身属性都不可配置且因此不可删除（但不一定是不可写）的对象。
	</p>
	<p>
		// 新建的对象默认不是密封的.<br />
		var empty = {};<br />
		Object.isSealed(empty); // === false<br />
		
		// 如果你把一个空对象变的不可扩展,则它同时也会变成个密封对象.<br />
		Object.preventExtensions(empty);<br />
		Object.isSealed(empty); // === true<br />
		
		// 但如果这个对象不是空对象,则它不会变成密封对象,因为密封对象的所有自身属性必须是不可配置的.<br />
		var hasProp = { fee: "fie foe fum" };<br />
		Object.preventExtensions(hasProp);<br />
		Object.isSealed(hasProp); // === false<br />
		
		// 如果把这个属性变的不可配置,则这个对象也就成了密封对象.<br />
		Object.defineProperty(hasProp, "fee", { configurable: false });<br />
		Object.isSealed(hasProp); // === true<br />
		
		// 最简单的方法来生成一个密封对象,当然是使用Object.seal.<br />
		var sealed = {};<br />
		Object.seal(sealed);<br />
		Object.isSealed(sealed); // === true<br />
		
		// 一个密封对象同时也是不可扩展的.<br />
		Object.isExtensible(sealed); // === false<br />
		
		// 一个密封对象也可以是一个冻结对象,但不是必须的.<br />
		Object.isFrozen(sealed); // === true ，所有的属性都是不可写的<br />
		var s2 = Object.seal({ p: 3 });<br />
		Object.isFrozen(s2); // === false， 属性"p"可写<br />
		
		var s3 = Object.seal({ get p() { return 0; } });<br />
		Object.isFrozen(s3); // === true ，访问器属性不考虑可写不可写,只考虑是否可配置
	</p>
	
	<h5>16.Object.keys() </h5>
	<p>
		Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。 
	</p>
	<p>
		语法<br />
		
		Object.keys(obj)<br />
		参数<br />
		
		obj<br />
		要返回其枚举自身属性的对象。<br />
		返回值<br />
		
		一个表示给定对象的所有可枚举属性的字符串数组。
	</p>
	<p>
		Object.keys 返回一个所有元素为字符串的数组，其元素来自于从给定的对象上面可直接枚举的属性。这些属性的顺序与手动遍历该对象属性时的一致。
	</p>
	<p>
		/* Array 对象 */ <br />
		let arr = ["a", "b", "c"];<br />
		console.log(Object.keys(arr)); <br />
		// ['0', '1', '2']<br />
		
		/* Object 对象 */ <br />
		let obj = { foo: "bar", baz: 42 }, <br />
		    keys = Object.keys(obj);<br />
		// CCAC: Chrome Console Auto Copy<br />
		copy(keys); <br />
		// ["foo","baz"]<br />
		
		/* 类数组 对象 */ <br />
		let obj = { 0 : "a", 1 : "b", 2 : "c"};<br />
		console.log(Object.keys(obj)); <br />
		// ['0', '1', '2']<br />
		
		注意：<br />
		var obj = { 0:"a", 1:"b", 2:{3:"c", 4:"d"}};<br />
		console.log(Object.keys(obj));<br />
		// (3) ["0", "1", "2"]<br />
		
		// 类数组 对象, 随机 key 排序 <br />
		let anObj = { 100: 'a', 2: 'b', 7: 'c' }; <br />
		
		console.log(Object.keys(anObj)); <br />
		// ['2', '7', '100']<br />
		
		/* getFoo 是个不可枚举的属性 */ <br />
		var my_obj = Object.create(<br />
		   <kon></kon>{}, <br />
		   <kon></kon>{ getFoo : { value : function () { return this.foo } } }<br />
		);<br />
		my_obj.foo = 1;<br />
		
		console.log(Object.keys(my_obj)); <br />
		// ['foo']<br />
		//如果你想获取一个对象的所有属性,，甚至包括不可枚举的，请查看Object.getOwnPropertyNames。
	</p>
	
	
	
	
	<h5>17.Object.preventExtensions() </h5>
	<p>
		Object.preventExtensions()方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。
	</p>
	<p>
		语法
		<br />
		<kon></kon>Object.preventExtensions(obj)<br />
		参数<br />
		
		<kon></kon>obj<br />
		将要变得不可扩展的对象。<br />
		返回值<br />
		
		<kon></kon>已经不可扩展的对象。
	</p>
	<p>
		如果一个对象可以添加新的属性，则这个对象是可扩展的。Object.preventExtensions()将对象标记为不再可扩展，因此它将永远不会具有超出它被标记为不可扩展的属性。注意，一般来说，不可扩展对象的属性可能仍然可被删除。尝试将新属性添加到不可扩展对象将静默失败或抛出TypeError（最常见但不排除其他情况，如在strict mode中）。
<br />
Object.preventExtensions()仅阻止添加自身的属性。但属性仍然可以添加到对象原型。
<br />
一旦使其不可扩展，就无法再对象进行扩展。
	</p>
	<p>
		// Object.preventExtensions将原对象变的不可扩展,并且返回原对象.<br />
		var obj = {};<br />
		var obj2 = Object.preventExtensions(obj);<br />
		obj === obj2;  // true<br />
		 
		// 字面量方式定义的对象默认是可扩展的.<br />
		var empty = {};<br />
		Object.isExtensible(empty) //=== true<br />
		 
		// ...但可以改变.<br />
		Object.preventExtensions(empty);<br />
		Object.isExtensible(empty) //=== false<br />
		 
		// 使用Object.defineProperty方法为一个不可扩展的对象添加新属性会抛出异常.<br />
		var nonExtensible = { removable: true };<br />
		Object.preventExtensions(nonExtensible);<br />
		Object.defineProperty(nonExtensible, "new", { value: 8675309 }); // 抛出TypeError异常<br />
		 
		// 在严格模式中,为一个不可扩展对象的新属性赋值会抛出TypeError异常.<br />
		function fail()<br />
		{<br />
		  "use strict";<br />
		  nonExtensible.newProperty = "FAIL"; // throws a TypeError<br />
		}<br />
		fail();<br />
		 
		// 一个不可扩展对象的原型是不可更改的,__proto__是个非标准魔法属性,可以更改一个对象的原型.<br />
		var fixed = Object.preventExtensions({});<br />
		fixed.__proto__ = { oh: "hai" }; // 抛出TypeError异常
	</p>
	<h5>
		18.Object.seal()
	</h5>
	<p>
		Object.seal() 方法可以让一个对象密封，并返回被密封后的对象。密封对象将会阻止向对象添加新的属性，并且会将所有已有属性的可配置性（configurable）置为不可配置（false），即不可修改属性的描述或删除属性。但是可写性描述（writable）为可写（true）的属性的值仍然可以被修改。
	</p>
	<p>
		语法<br />
		
		<kon></kon>Object.seal(obj)<br />
		参数<br />
		
		<kon></kon>obj<br />
		返回
		<kon></kon>将要被密封的对象
	</p>
	<p>
		通常情况下，一个对象是可扩展的（可以添加新的属性）。密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出TypeError 异常（严格模式）。
<br />
不会影响从原型链上继承的属性。但 __proto__ (  ) 属性的值也会不能修改。
	</p>
	<p>
		var obj = {<br />
		    <kon></kon>prop: function () {},<br />
		    <kon></kon>foo: "bar"<br />
		  };<br />
		
		// 可以添加新的属性,已有属性的值可以修改,可以删除<br />
		obj.foo = "baz";<br />
		obj.lumpy = "woof";<br />
		delete obj.prop;<br />
		
		var o = Object.seal(obj);<br />
		
		assert(o === obj);<br />
		assert(Object.isSealed(obj) === true);<br />
		
		// 仍然可以修改密封对象上的属性的值.<br />
		obj.foo = "quux";<br />
		
		// 但你不能把一个数据属性重定义成访问器属性.<br />
		Object.defineProperty(obj, "foo", { get: function() { return "g"; } }); // 抛出TypeError异常<br />
		
		// 现在,任何属性值以外的修改操作都会失败.<br />
		obj.quaxxor = "the friendly duck"; // 静默失败,新属性没有成功添加<br />
		delete obj.foo; // 静默失败,属性没有删除成功<br />
		
		// ...在严格模式中,会抛出TypeError异常<br />
		function fail() {<br />
		 <kon></kon> "use strict";<br />
		 <kon></kon> delete obj.foo; // 抛出TypeError异常<br />
		 <kon></kon> obj.sparky = "arf"; // 抛出TypeError异常<br />
		}<br />
		fail();<br />
		
		// 使用Object.defineProperty方法同样会抛出异常<br />
		Object.defineProperty(obj, "ohai", { value: 17 }); // 抛出TypeError异常<br />
		Object.defineProperty(obj, "foo", { value: "eit" }); // 成功将原有值改变
	</p>
	<h5>
		19.Object.setPrototypeOf() 
	</h5>
	<p>
		Object.setPrototypeOf() 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  null。
	</p>
	<p>
		语法<br />
		
		<kon></kon>Object.setPrototypeOf(obj, prototype)<br />
		参数<br />
		
		<kon></kon>obj<br />
		要设置其原型的对象。<br />
		<kon></kon>prototype<br />
		该对象的新原型(一个对象 或 null).
	</p>
	<p>
		如果对象的[[Prototype]]被修改成不可扩展(通过 Object.isExtensible()查看)，就会抛出 TypeError异常。如果prototype参数不是一个对象或者null(例如，数字，字符串，boolean，或者 undefined)，则什么都不做。否则，该方法将obj的[[Prototype]]修改为新的值。
<br />
Object.setPrototypeOf()是ECMAScript 6最新草案中的方法，相对于 Object.prototype.__proto__ ，它被认为是修改对象原型更合适的方法
	</p>
	<p>
		var dict = Object.setPrototypeOf({}, null);
	</p>
	<p>
		<span style="color:#c33;">警告：</span>
		由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的 [[Prototype]]在各个浏览器和 JavaScript 引擎上都是一个很慢的操作。其在更改继承的性能上的影响是微妙而又广泛的，这不仅仅限于 obj.__proto__ = ... 语句上的时间花费，而且可能会延伸到任何代码，那些可以访问任何[[Prototype]]已被更改的对象的代码。如果你关心性能，你应该避免设置一个对象的 [[Prototype]]。相反，你应该使用 Object.create()来创建带有你想要的[[Prototype]]的新对象。
	</p>
	<h5>
		20.Object.values()
	</h5>
	<p>
		Object.values()方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。
	</p>
	<p>
		语法<br />
		
		<kon></kon>Object.values(obj)<br />
		参数<br />
		
		obj<br />
		<kon></kon>被返回可枚举属性值的对象。<br />
		返回值<br />
		
		<kon></kon>一个包含对象自身的所有可枚举属性值的数组。
	</p>
	<p>
		Object.values()返回一个数组，其元素是在对象上找到的可枚举属性值。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。
	</p>
	<p>
		var obj = { foo: "bar", baz: 42 };<br />
		console.log(Object.values(obj)); // ['bar', 42]<br />
		
		// 类数组对象<br />
		var obj = { 0: 'a', 1: 'b', 2: 'c' };<br />
		console.log(Object.values(obj)); // ['a', 'b', 'c']<br />
		注意：<br />
		var obj = { 0: 'a', 1: 'b', 2: { 3: 'c' , 4: 'd' } };<br />
		console.log(Object.values(obj));  <br />
		// ["a", "b", {…}] 内置的对象没有扩展成数组<br />
		
		// 随机键值的类数组对象<br />
		var an_obj = { 100: 'a', 2: 'b', 7: 'c' };<br />
		console.log(Object.values(an_obj)); // ['b', 'c', 'a']<br />
		
		// getFoo 是不可枚举属性<br />
		var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });<br />
		my_obj.foo = "bar";<br />
		console.log(Object.values(my_obj)); // ['bar']<br />
		
		// 参数是非对象会转变成对象<br />
		console.log(Object.values("foo")); // ['f', 'o', 'o']
	</p>
	
	<p>经过查阅资料整理，暂时就到这里，后续还会补充。如有错误，请不吝赐教！</p>
</div>
	
	</body>
</html>

